name: 自动清理所有工作流运行记录
on:
  schedule:
    - cron: '0 0 * * *'  # 每天凌晨自动运行
  workflow_dispatch:  # 允许手动触发

jobs:
  cleanup-all-workflows:
    runs-on: ubuntu-latest
    steps:
      - name: 安装jq工具
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: 清理所有工作流的旧运行记录
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          REPO_OWNER: "1013608955"
          REPO_NAME: "mkdy"
          RETAIN_DAYS: 7
          MAX_RETAIN_COUNT: 100
        run: |
          # 1. 获取仓库中所有工作流的ID列表
          echo "正在获取仓库中所有工作流..."
          WORKFLOW_IDS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/workflows" | \
            jq -r '.workflows[].id')

          if [ -z "$WORKFLOW_IDS" ]; then
            echo "未找到任何工作流，清理结束"
            exit 0
          fi
          echo "找到的工作流ID列表：$WORKFLOW_IDS"

          # 2. 遍历每个工作流ID，逐个清理旧运行记录
          for WORKFLOW_ID in $WORKFLOW_IDS; do
            echo -e "\n========== 开始清理工作流ID: $WORKFLOW_ID =========="
            
            # 新增：处理GitHub API分页，获取该工作流的所有运行记录
            echo "正在获取工作流$WORKFLOW_ID的所有运行记录（处理分页）..."
            ALL_RUNS=()
            PAGE=1
            while true; do
              # 分页请求运行记录（每页100条）
              PAGE_RUNS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/workflows/$WORKFLOW_ID/runs?per_page=100&page=$PAGE")
              
              # 提取当前页的运行记录ID（若为空则终止分页）
              PAGE_RUNS_IDS=$(echo "$PAGE_RUNS" | jq -r '.workflow_runs[].id')
              if [ -z "$PAGE_RUNS_IDS" ] || [ "$PAGE_RUNS_IDS" == "null" ]; then
                break
              fi
              
              # 将当前页的运行记录（完整信息）加入ALL_RUNS
              PAGE_RUNS_DETAIL=$(echo "$PAGE_RUNS" | jq -c '.workflow_runs[]')
              ALL_RUNS+=("$PAGE_RUNS_DETAIL")
              
              PAGE=$((PAGE + 1))
              sleep 1  # 避免API限流
            done

            # 将ALL_RUNS转为JSON数组，方便jq处理
            ALL_RUNS_JSON=$(printf "%s\n" "${ALL_RUNS[@]}" | jq -s '.')
            RUNS_COUNT=$(echo "$ALL_RUNS_JSON" | jq -r 'length')
            echo "工作流$WORKFLOW_ID 共获取到 $RUNS_COUNT 条运行记录"

            if [ "$RUNS_COUNT" -eq 0 ]; then
              echo "工作流$WORKFLOW_ID 无运行记录，跳过清理"
              continue
            fi

            # 筛选需要删除的运行记录：保留前MAX_RETAIN_COUNT条，且剩余记录超过RETAIN_DAYS
            TO_DELETE=$(echo "$ALL_RUNS_JSON" | jq -r --arg DAYS "$RETAIN_DAYS" --arg COUNT "$MAX_RETAIN_COUNT" '
              sort_by(.created_at) | reverse  # 按时间降序排列（最新在前）
              | .[($COUNT | tonumber):]  # 保留前$COUNT条，取剩余记录
              | map(select(.created_at < (now - ($DAYS | tonumber) * 86400 | strftime("%Y-%m-%dT%H:%M:%SZ"))))  # 过滤超过$DAYS天的
              | .[].id
            ')

            if [ -z "$TO_DELETE" ] || [ "$TO_DELETE" == "null" ]; then
              echo "工作流$WORKFLOW_ID 暂无需要清理的运行记录"
              continue
            fi

            # 逐个删除符合条件的运行记录
            echo "工作流$WORKFLOW_ID 待删除的运行ID：$TO_DELETE"
            for RUN_ID in $TO_DELETE; do
              echo "正在删除运行记录 $RUN_ID"
              curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/actions/runs/$RUN_ID"
              sleep 1  # 避免API限流
            done
            echo -e "========== 工作流$WORKFLOW_ID 清理完成 ==========\n"
          done

          echo "所有工作流清理完成！"
